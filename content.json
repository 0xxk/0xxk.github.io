{"meta":{"title":"0xxk'sBlog","subtitle":null,"description":null,"author":"John Doe","url":"https://0xxk.github.com","root":"/"},"pages":[{"title":"","date":"2019-07-24T03:02:10.638Z","updated":"2019-07-24T03:02:10.588Z","comments":true,"path":"about/index.html","permalink":"https://0xxk.github.com/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2019-08-01T16:13:45.000Z","updated":"2019-08-01T16:15:32.545Z","comments":true,"path":"categories/index.html","permalink":"https://0xxk.github.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2019-07-24T06:59:13.814Z","updated":"2019-07-24T03:02:35.295Z","comments":true,"path":"tags/index.html","permalink":"https://0xxk.github.com/tags/index.html","excerpt":"","text":"layout:tags comments:fasle document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"CSRF JQ POST提交","slug":"CSRF JQ POST提交","date":"2019-08-04T15:53:36.787Z","updated":"2019-08-04T16:23:40.719Z","comments":true,"path":"2019/08/04/CSRF JQ POST提交/","link":"","permalink":"https://0xxk.github.com/2019/08/04/CSRF JQ POST提交/","excerpt":"​ 在温习完前端后，继续学习了JS JQ。在讲JQ时，讲师用JQ本地复现了一遍CSRF。因为我对CSRF的理解一直处于概念上，所以就此机会将JQ复现代码学习理解一遍！","text":"​ 在温习完前端后，继续学习了JS JQ。在讲JQ时，讲师用JQ本地复现了一遍CSRF。因为我对CSRF的理解一直处于概念上，所以就此机会将JQ复现代码学习理解一遍！ 某小游戏网csrf POST更改账户信息。代码具体如下： 123456789101112131415161718192021222324252627282930 jquery $.ajax({ type: 'POST', url:'http://www.xxxx.com/xxxapi/user/info', dataType: 'json', data: { \"headimg\":\"/static/usericon/userphoto20.png\", \"user_tag\":[], \"allow_status\":\"1\", \"nickname\":\"Leafer\", \"real_name\":\"\", \"id_number\":\"\"}, xhrFields: { withCredentials:true //支持附带详细信息,可以携带cookie }, crossDomain: true,//请求偏向外域,支持跨域请求 success: function (data) { console.log(data); } }); 本例 type为’POST’。type默认值为”GET”，可选”GET”或”POST”。 url为发送请求的地址。 dataType为传递的数据类型。本处为”JSON”。可用值如下： “xml”:返回XML文档； “html”:返回纯文本HTML信息； “script”:返回纯文本JavaScript代码。 “json”:返回JSON数据 “jsconp”:JSONP格式 “text”:返回纯文本字符串。 xhrFields: {withCredentials:true}支持附带详细信息,携带cookie crossDomain:ture 请求偏向外语，支持跨域请求 success: function (data) {console.log(data);}请求成功后在控制台输出data数据。 访问页面后 参数为： 响应值为： 再去查看自己的昵称 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"DOM与BOM的异同","slug":"DOM和BOM","date":"2019-08-01T16:03:45.508Z","updated":"2019-08-01T16:03:45.509Z","comments":true,"path":"2019/08/02/DOM和BOM/","link":"","permalink":"https://0xxk.github.com/2019/08/02/DOM和BOM/","excerpt":"​ DOM操作页面，BOM操作浏览器。听到这句话时，我感觉自己的基础不是很扎实。脑海里复现的问题竟然是DOM是什么？BOM是什么？","text":"​ DOM操作页面，BOM操作浏览器。听到这句话时，我感觉自己的基础不是很扎实。脑海里复现的问题竟然是DOM是什么？BOM是什么？ 为什么COM能操作页面？为什么BOM能操作浏览器？他们之间有什么共同点？有什么不同点呢？既然问题出来了，那我们就一一百度解决！ DOM是什么？​ DOM全称Document Object Model，即文档对象模型。我理解的DOM是一个接口，它接在HTML代码中。就像document.getElementById(‘xxx’)一样，它把Id为“myBtn”的节点“引用”到了这里。就相当于API接口，这样用脚本（JS）控制Web界面就很方便。（观点浅薄，请自行深入） BOM是什么？​ BOM全称Browser Object Model，即浏览器对象模型。它也是接口，它的口接在全局对象中。也就是可以网页中，我们可以通过BOM接口加上一些动作来对浏览器进行控制。 为什么COM能操作页面？为什么BOM能操作浏览器？​ 因为它们都是各自对象模型的接口（分别对应：文档对象模型，浏览器对象模型）。就像一个是手机的屏幕，一个是汽车的方向盘。都能都过对应的那一个点去操控各自的模型。 他们之间有什么共同点？有什么不同点呢？浅谈 不同点：各自操作不同的模型。 相同点：你中有我，我中有你。 深论 javascript由三部分组成：ECMAScript,DOM,BOM组成。 123DOM是W3C的标准；[所有浏览器公共遵守的标准]BOM是各个浏览器厂商根据DOM在各自浏览器上的实现;[表现为不同浏览器定义有差别，实现方式不同]window是BOM对象，而非js对象。 ​ DOM（文档对象模型）是HTML和XML的应用程序接口（API）。​ BOM主要处理浏览器窗口和框架，不过通常浏览器特定的JavaScript扩展都被看做BOM的一部分。这些扩展包括： 123456弹出新的浏览器窗口移动、关闭浏览器窗口以及调整窗口大小提供web浏览器详细信息的定位对象提供用户品目分辨率详细信息的屏幕对象对cookie的支持IE扩展了BOM，加入了ActiveXObject类，可以通过JavaScript实例化Activex对象 ​ javascript是通过访问BOM对象来访问、控制、修改客户端（浏览器），由于BOM的window包含了document,window对象的属性和方法是直接可以使用而且被感知的，因此可以直接使用winodw对象的document属性。 ​ 通过document属性就可以访问、检索、修改XHTML文档内容与结构。因为document对象又是DOM模型的根节点。可以说，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。其中DOM包含:window 分类 window对象包含属性：document、location、navigater、screen、history、frames。 Document根节点包含子节点：forms、location、anchors、images、links 从window.document已然可以看出，DOM最根本的对象是BOM window对象的子对象。 参考链接：https://blog.csdn.net/xiao_tommy/article/details/53231165 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程","slug":"编程","permalink":"https://0xxk.github.com/categories/编程/"}],"tags":[]},{"title":"JS事件初识","slug":"JS事件","date":"2019-07-31T16:29:07.669Z","updated":"2019-07-31T16:34:54.482Z","comments":true,"path":"2019/08/01/JS事件/","link":"","permalink":"https://0xxk.github.com/2019/08/01/JS事件/","excerpt":"学习了JS后发现自己还有很多很多不会的东西。对于陌生的语言，从基础开始学习是非常有必要的。","text":"学习了JS后发现自己还有很多很多不会的东西。对于陌生的语言，从基础开始学习是非常有必要的。 但对于快速的课程而言，就此只针对课上出现过的事件进行学习!一.getElementById()方法 getElementById()方法可返回拥有指定ID的第一个对象的引用。 语法: 1document.getElementById(id) 举例： 1234567891011121314function getValue(){var x=document.getElementById(\"myHeader\")alert(x.innerHTML)} 这是标题点击标题，会提示出它的值。 可以看到代码里监听了”MyHeader”，当id为myHeafer的值被点击时，就触发后面的动作，也就是alert(x.innerHTML)，当我们点击时就触发了。 二.getElementById是引用他人再做出动作，但是下面的方法就有些不一样了。 12345678910111213141516171819202122菜鸟教程(runoob.com)单击按钮创建一个标题点我function myFunction(){ var h=document.createElement(\"H1\"); var t=document.createTextNode(\"Hello World\"); h.appendChild(t); document.body.appendChild(h);}; 在上面的代码里用到了 1234document.getElementByid(\"myBtn\").addEventListener(\"click\",function(){document.getElementByld(\"demo\").innerHTML = \"Hello World\"; }); 这里的document.getElementByid(“myBtn”).addEventListerner 就不是引用id=myBtn的意思了。作用点在后面的addEventListerner，后面方法的作用是监听前面的id，当点击时满足条件从而去运行下面的函数。在这里有一个新的方法innerHTML。 innerHTML属性设置或返回表格行的开始和结束标签之间的HTML代码。 在这里的意思就是往前面id为demo的标签中间返回后面的“Hello World”代码。 这里代码的意思就是，当myBtn被点击时，则在demo标签的位置显示Hello World。 同理这里的”click”也可以改为”mousemove”，当移动到这个标签上时触发规则输出Hello World。 三.onclick事件在这里出现了新的句子。 12345678910111213141516171819菜鸟教程(runoob.com)function myFunction(){ document.getElementById(\"demo\").innerHTML=\"Hello World\";}单击按钮触发函数。点我 在这里出现了一个 1点我 是一个按钮标签。 一般来说这里我们都是些一个id去指定这个按钮。但是这里没有，当我们点击按钮后，这里直接通过onclick事件跳转了。他跳到了onclick=”myFunction()”后面的myFunction()函数处。 在函数中出现了另一个事件。通过引用”demo”这个标签，在ta的html范围内输出“Hello World”。从而这段代码的意思就是当我们点击按钮后在demo的代码范围内输出Hello World。 四.创建节点下面的js代码是单击按钮将项目添加到列表中。 1234567891011121314151617181920212223菜鸟教程(runoob.com)CoffeeTea单击按钮将项目添加到列表中点我function myFunction(){ var node=document.createElement(\"LI\"); var textnode=document.createTextNode(\"Water\"); node.appendChild(textnode); document.getElementById(\"myList\").appendChild(node);}注意:首先创建一个节点， 然后创建一个文本节点，然后将文本节点添加到LI节点上。最后将节点添加到列表中。 每点击一次“点我”，就在列表中增加一个值。 上面的代码执行顺序如下： 首先创建一个Li节点，然后创建一个文本节点，然后将文本节点增加到LI节点上。最后将节点增加到列表中。 createElement就是创建一个节点，createTextNode就是创建一个文本节点，appendChild就是将textnode（创建文本节点）加入到node(创建的节点)中去。 最后引用”myList” id，appendChild(node)将node(节点和文本节点的结合体)加入到标签中去。 五.createElement AND createTextNode继上一个onclick事件之后扩展出另外一个程序。如下： 12345678910111213141516171819202122菜鸟教程(runoob.com)单击按钮创建一个标题点我function myFunction(){ var h=document.createElement(\"H1\"); var t=document.createTextNode(\"Hello World\"); h.appendChild(t); document.body.appendChild(h);}; 这里出现了新的事件createElement()，createTextNode()。 createrElement()的作用是创建一个”H1”节点（字体大小），然后createTextNode(“Hello World”)创建一个对象。h.appendChild(t)将t”Hello World”加入加入“H1”中(字体也会相应的变最大)。最后将h对象加入body的最后面。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"phpMyAdmin4.8文件包含漏洞","slug":"test","date":"2019-07-28T08:57:33.796Z","updated":"2019-07-28T08:57:33.796Z","comments":true,"path":"2019/07/28/test/","link":"","permalink":"https://0xxk.github.com/2019/07/28/test/","excerpt":"首先来说下文件包含是什么，粗俗的讲就是本网页包含其他源代码来执行。此处本意正如编程中的函数调用，重复的代码大可不写。合理调用利用重复代码才是王道。","text":"首先来说下文件包含是什么，粗俗的讲就是本网页包含其他源代码来执行。此处本意正如编程中的函数调用，重复的代码大可不写。合理调用利用重复代码才是王道。 那么文件包含漏洞是什么呢？文件包含不该是正常网站的一个功能吗？用尘哥的话说就是xx程序员多了，就有了漏洞，就有了安全这行业。本来应该包含正确代码到文件中去执行的，但是在包含这个地方没有做好过滤。导致我们能让网站随我们心意“任意”执行我们想要做的“事情”。 在phpMyadmin4.0 4.1中就有这么一处包含的位置过滤不严导致可控。我们通过文件包含去调用我们“上传”到网站上的恶意代码，如：一句话木马。只要将其包含就可以“执行”。让我们先来认识下PHP中文件包含的函数： include() 使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行整个php文件。 include_once() 这个函数跟include函数作用几乎相同，只是他在导入函数之前先检测下改文件是否被导入。如果已经执行一遍那么就不重复执行了。 require() 使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。 require_once() 功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。 先让我们大致的浏览的一下phpMyadmin网站的结构。既然说是文件包含，那么漏洞点必然在包含的位置那。大致浏览了一波，好像没有找到明显的?xxx=xx.php这种页面。那么直接上手源代码吧，提示漏洞出在index.php中。让我们依次去查找文件包含的关键字： include() 搜索全文后发现只有这四个地方用到了包含include函数. include_once() 就只有一处 require 就只有这一处 Require_once 也只有这么一处。因为我们需要被包含文件位置可变（目前非可控）。所以除去所有相对路径后只剩下include中的两处了。分别是： 先让我们来分析下include $page的条件（哦吼，php学的烂看不懂。让我百度一波） $page中的数值会在函数中判断后由Utile类getScriptNameForOption函数返回值赋予。继续溯源到Util::getScriptNameForOption中去。 查看Util.php源代码，定位到3064行——3110行。代码分别如下 总的看了下它共有三个判断语句，如果传入的$location等于server、database、table中的一个。那么就进行swith($target)选择一个值return返回。由此可见，这个包含的地方不是漏洞点。现在只剩下include $_REQUEST[‘target’];了。 首先对涉及到的函数进行百度（菜是原罪） 1.empty:若变量已存在、非空字符串或者非零，则返回false值，反之返回true。 2.is_string:检测变量是否是字符串，如果是字符串返回TURE，反则返回FALSE。 3.preg_match:用于执行一个正则表达式匹配 4.in_array:搜索数组中是否存在指定的值。 5.将target传去Core类的checkPageValidity进行判断。 如果以上五项都为True，则执行下面的include $_REQUEST[‘target’]; 让我们依次来分析各项为True的条件。 empty()：要让后面的’target’存在或者是空字符串或者非零。这样empty返回0，和前面的！非一下就成了1. is_string：target的数值要为字符串。 preg_match:如果target满足正则条件则返回1。target字符串的头不能为index，否则！1就返回0。 in_array:target中的值不能出现在$target_blacklist中。$target_blacklist中有’import.php’和’export.php’。只要’target’中的值不包含’import.php’和’export.php’就可以了 Core::checkPageValidity：将’target’的值传入core类的checkPageValidity函数中去进行判断。如果返回的数值为True，那么就为1。对Core::checkPageValidity进行溯源： 进入Core.php，定位checkPageValidity函数进行判断。 大致查看下有哪些判断条件，共有五个判断语句。如下逐个分析： 在这个if中，因为我们没有给whitelist传送一个值过来，所以导致这里empty($whitelist)为True。转而执行下面的$whitelist = self::$goto_whitelist;在slfe::$goto_whitelist中存放着白名单。这里将白名单赋予给$whitelist变量。 goto_whitelist白名单如下（部分）： 在这里变量page也就是传入的target要被定义过或是字符串，否则返回false。 我们传入的变量如果是白名单里的一种，那么就返回true。 5.这里用到了mb_substr函数和mb_strpos函数。mb_substr的作用是返回字符串的一部分。mb_strpos这里是判断后面字符出现的位置。这里总的含义就是将变量page里出现在?号前面的数据截取后传入$_page。如下举例： 在这里我曾有一个zz的地方，知道mb_strpos函数的作用后不免思考：为什么要加上一个？号后再判断它位置来截断呢？毫无意思的操作，自己加然后截断自己的参数。从而导致我觉得.号作用不是拼接而有其他意思。后来如上图试验后才明白函数原来是从左往后去判断截断的。如果在用户输入有?的前提下将文件名和参数分开，没有?时也可以取出文件名。 但是在这里有一个问题，正如我们上面使用的语句：db_sql.php?/../../../../../../etc/passwd。它虽然绕过了之前所有的过滤，但是在php中问号后面的是会被当作参数来执行的。那还是达不到包含文件的作用的！继续来看下面的参数！ 5.在这里有一个很有趣的地方，那就是urldecode()。他的作用是将url编码解码一次，那么在这里就很有意思了！ 它将解码后的在拿去判断，这是无用的！因为php最后包含的是解码之前的代码！如下所示： 文件包含的是db_sql.php%3f/../../../../../../etc/passwd，可解码后判断的是db_sql.php?/../../../../../../etc/passwd这是不一样的。这这个if里我们顺利通过了关键字白名单判断且用正确格式包含了自己想要得到的数据。 综合上面所有的判定条件。我们要通过target参数传入一串字符串，字符串前面的文件名要在白名单中，且？要进行二次url编码（浏览器传送时会自动解码一次）。这样就可以绕过所有的过滤达到我们要的效果了。 如下所示： 因本人很菜，无法在默认配置下利用文件包含漏洞点去拿getshell。至此只写下如何查看phpinfo()。 一．通过数据库写入phpinfo()从而来包含。 再来查看当前数据库位置 具体目录根据保存规则推算。在这里tt.frm得允许其他人可读。 二．第二种方法就是网上常见得包含Php日志。 在这里不需要sess_sxxxx有读权限。因为文件本身的所有者就是apache。二第一种方法之所以要其他人读权限。是因为数据库本身的所有者是apache document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"0xxk的第一篇文章","slug":"hello-world","date":"2019-07-28T08:30:57.112Z","updated":"2019-07-28T08:30:57.112Z","comments":true,"path":"2019/07/28/hello-world/","link":"","permalink":"https://0xxk.github.com/2019/07/28/hello-world/","excerpt":"很高兴大家来到我的博客，希望我们能够在这共同学习共同进步！","text":"很高兴大家来到我的博客，希望我们能够在这共同学习共同进步！ 创建博客的过程第一步12$在博主的github上git下载，网址为：https://github.com/Tomotoes/hexo-theme-tomotoes 第二步12$在Blog/_config.yml中修改theme: 主题名。这里的主题名即上一个目录theme中你下载的主题名。 第三步12345$ 在当前目录下分别执行 ： hexo clean hexo s hexo g在执行完之后可以看到一个非常简陋的网站，这是因为很多依赖的环境都没有加载 第四步123$ 进去博主的安装链接中：https://github.com/Tomotoes/hexo-theme-tomotoes/wiki/%E5%AE%89%E8%A3%85依次执行其中的命令，最后就可以看到很好看的网站了 第五步1$为了我们的网站更加的好看，我们可以去百度教程进一步美化我们的页面。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}]}