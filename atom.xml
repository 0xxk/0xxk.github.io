<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0xxk&#39;sBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://0xxk.github.com/"/>
  <updated>2019-07-28T08:57:33.796Z</updated>
  <id>https://0xxk.github.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>phpMyAdmin4.8文件包含漏洞</title>
    <link href="https://0xxk.github.com/2019/07/28/test/"/>
    <id>https://0xxk.github.com/2019/07/28/test/</id>
    <published>2019-07-28T08:57:33.796Z</published>
    <updated>2019-07-28T08:57:33.796Z</updated>
    
    <content type="html"><![CDATA[<p>  首先来说下文件包含是什么，粗俗的讲就是本网页包含其他源代码来执行。此处本意正如编程中的函数调用，重复的代码大可不写。合理调用利用重复代码才是王道。</p><a id="more"></a><p>那么文件包含漏洞是什么呢？文件包含不该是正常网站的一个功能吗？用尘哥的话说就是xx程序员多了，就有了漏洞，就有了安全这行业。本来应该包含正确代码到文件中去执行的，但是在包含这个地方没有做好过滤。导致我们能让网站随我们心意“任意”执行我们想要做的“事情”。</p><p>  在phpMyadmin4.0 4.1中就有这么一处包含的位置过滤不严导致可控。我们通过文件包含去调用我们“上传”到网站上的恶意代码，如：一句话木马。只要将其包含就可以“执行”。<br>让我们先来认识下PHP中文件包含的函数：</p><p>  include()</p><p>使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行整个php文件。</p><p>  include_once()</p><p>这个函数跟include函数作用几乎相同，只是他在导入函数之前先检测下改文件是否被导入。如果已经执行一遍那么就不重复执行了。</p><p>  require()</p><p>使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。</p><p>  require_once()</p><p>功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。</p><p>先让我们大致的浏览的一下phpMyadmin网站的结构。既然说是文件包含，那么漏洞点必然在包含的位置那。大致浏览了一波，好像没有找到明显的?xxx=xx.php这种页面。那么直接上手源代码吧，提示漏洞出在index.php中。让我们依次去查找文件包含的关键字：</p><p>  include()</p><p>  <img src="https://b2.bmp.ovh/imgs/2019/07/c808e947e90f8b27.png" alt></p><p>  <img src="https://b2.bmp.ovh/imgs/2019/07/aa9ab63e7f9a8544.png" alt></p><p>  <img src="https://b2.bmp.ovh/imgs/2019/07/8320934fc9a999e3.png" alt></p><p>  <img src="https://b2.bmp.ovh/imgs/2019/07/0674ca60ee73dc17.png" alt><br>  搜索全文后发现只有这四个地方用到了包含include函数.</p><p>include_once()</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://b2.bmp.ovh/imgs/2019/07/de97f23630670e65.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>就只有一处</p><p>require</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://b2.bmp.ovh/imgs/2019/07/53d2315cd601428b.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>就只有这一处</p><p>Require_once</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://b2.bmp.ovh/imgs/2019/07/e54a00ac99cd2747.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>也只有这么一处。<br>因为我们需要被包含文件位置可变（目前非可控）。所以除去所有相对路径后只剩下include中的两处了。<br>分别是：</p><p><img src="https://b2.bmp.ovh/imgs/2019/07/2f5d9f00745ae085.png" alt>    <img src="https://b2.bmp.ovh/imgs/2019/07/58e737094b5b901c.png" alt></p><p>先让我们来分析下include $page的条件（哦吼，php学的烂看不懂。让我百度一波）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://b2.bmp.ovh/imgs/2019/07/9ae651d090d9872c.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>$page中的数值会在函数中判断后由Utile类getScriptNameForOption函数返回值赋予。继续溯源到Util::getScriptNameForOption中去。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/el6bk9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>查看Util.php源代码，定位到3064行——3110行。代码分别如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elcU74.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elcgBD.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elcogP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>总的看了下它共有三个判断语句，如果传入的$location等于server、database、table中的一个。那么就进行swith($target)选择一个值return返回。由此可见，这个包含的地方不是漏洞点。<br>现在只剩下include $_REQUEST[‘target’];了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elcqHg.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>首先对涉及到的函数进行百度（菜是原罪）</p><p>1.empty:若变量已存在、非空字符串或者非零，则返回false值，反之返回true。</p><p>2.is_string:检测变量是否是字符串，如果是字符串返回TURE，反则返回FALSE。</p><p>3.preg_match:用于执行一个正则表达式匹配</p><p>4.in_array:搜索数组中是否存在指定的值。</p><p>5.将target传去Core类的checkPageValidity进行判断。</p><p>如果以上五项都为True，则执行下面的include $_REQUEST[‘target’];</p><p>让我们依次来分析各项为True的条件。</p><p>empty()：要让后面的’target’存在或者是空字符串或者非零。这样empty返回0，和前面的！非一下就成了1.</p><p>is_string：target的数值要为字符串。</p><p>preg_match:如果target满足正则条件则返回1。target字符串的头不能为index，否则！1就返回0。</p><p>in_array:target中的值不能出现在$target_blacklist中。$target_blacklist中有’import.php’和’export.php’。只要’target’中的值不包含’import.php’和’export.php’就可以了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elgibF.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Core::checkPageValidity：将’target’的值传入core类的checkPageValidity函数中去进行判断。如果返回的数值为True，那么就为1。对Core::checkPageValidity进行溯源：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elU3NT.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>进入Core.php，定位checkPageValidity函数进行判断。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elU84U.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>大致查看下有哪些判断条件，共有五个判断语句。如下逐个分析：</p><p>在这个if中，因为我们没有给whitelist传送一个值过来，所以导致这里empty($whitelist)为True。转而执行下面的$whitelist = self::$goto_whitelist;在slfe::$goto_whitelist中存放着白名单。这里将白名单赋予给$whitelist变量。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/el2GeU.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>goto_whitelist白名单如下（部分）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elUgvd.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在这里变量page也就是传入的target要被定义过或是字符串，否则返回false。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elUI58.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>我们传入的变量如果是白名单里的一种，那么就返回true。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elaMxH.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>5.这里用到了mb_substr函数和mb_strpos函数。mb_substr的作用是返回字符串的一部分。mb_strpos这里是判断后面字符出现的位置。这里总的含义就是将变量page里出现在?号前面的数据截取后传入$_page。如下举例：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elaJdP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elaaRg.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p> 在这里我曾有一个zz的地方，知道mb_strpos函数的作用后不免思考：为什么要加上一个？号后再判断它位置来截断呢？毫无意思的操作，自己加然后截断自己的参数。从而导致我觉得.号作用不是拼接而有其他意思。后来如上图试验后才明白函数原来是从左往后去判断截断的。如果在用户输入有?的前提下将文件名和参数分开，没有?时也可以取出文件名。</p><p>但是在这里有一个问题，正如我们上面使用的语句：<br>db_sql.php?/../../../../../../etc/passwd。它虽然绕过了之前所有的过滤，但是在php中问号后面的是会被当作参数来执行的。那还是达不到包含文件的作用的！继续来看下面的参数！</p><p>5.在这里有一个很有趣的地方，那就是urldecode()。他的作用是将url编码解码一次，那么在这里就很有意思了！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/ela0Mj.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>它将解码后的在拿去判断，这是无用的！因为php最后包含的是解码之前的代码！如下所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elaRWF.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>文件包含的是db_sql.php%3f/../../../../../../etc/passwd，可解码后判断的是db_sql.php?/../../../../../../etc/passwd这是不一样的。这这个if里我们顺利通过了关键字白名单判断且用正确格式包含了自己想要得到的数据。</p><p>综合上面所有的判定条件。我们要通过target参数传入一串字符串，字符串前面的文件名要在白名单中，且？要进行二次url编码（浏览器传送时会自动解码一次）。这样就可以绕过所有的过滤达到我们要的效果了。</p><p>如下所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elaTdx.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>因本人很菜，无法在默认配置下利用文件包含漏洞点去拿getshell。至此只写下如何查看phpinfo()。</p><p>一．通过数据库写入phpinfo()从而来包含。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elajQH.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>再来查看当前数据库位置</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/eld3pF.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>具体目录根据保存规则推算。在这里tt.frm得允许其他人可读。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/eldwtK.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>二．第二种方法就是网上常见得包含Php日志。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/07/28/elds6H.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在这里不需要sess_sxxxx有读权限。因为文件本身的所有者就是apache。二第一种方法之所以要其他人读权限。是因为数据库本身的所有者是apache</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  首先来说下文件包含是什么，粗俗的讲就是本网页包含其他源代码来执行。此处本意正如编程中的函数调用，重复的代码大可不写。合理调用利用重复代码才是王道。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>0xxk的第一篇文章</title>
    <link href="https://0xxk.github.com/2019/07/28/hello-world/"/>
    <id>https://0xxk.github.com/2019/07/28/hello-world/</id>
    <published>2019-07-28T08:30:57.112Z</published>
    <updated>2019-07-28T08:30:57.112Z</updated>
    
    <content type="html"><![CDATA[<p>很高兴大家来到我的博客，希望我们能够在这共同学习共同进步！</p><a id="more"></a><h2 id="创建博客的过程"><a href="#创建博客的过程" class="headerlink" title="创建博客的过程"></a>创建博客的过程</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$在博主的github上git下载，网址为：</span><br><span class="line">https://github.com/Tomotoes/hexo-theme-tomotoes</span><br></pre></td></tr></tbody></table></figure><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$在Blog/_config.yml中修改theme: 主题名。</span><br><span class="line">这里的主题名即上一个目录theme中你下载的主题名。</span><br></pre></td></tr></tbody></table></figure><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ 在当前目录下分别执行 ：</span><br><span class="line">                    hexo clean</span><br><span class="line">                    hexo s</span><br><span class="line">                    hexo g</span><br><span class="line">在执行完之后可以看到一个非常简陋的网站，这是因为很多依赖的环境都没有加载</span><br></pre></td></tr></tbody></table></figure><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ 进去博主的安装链接中：</span><br><span class="line">https://github.com/Tomotoes/hexo-theme-tomotoes/wiki/%E5%AE%89%E8%A3%85</span><br><span class="line">依次执行其中的命令，最后就可以看到很好看的网站了</span><br></pre></td></tr></tbody></table></figure><h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$为了我们的网站更加的好看，我们可以去百度教程进一步美化我们的页面。</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很高兴大家来到我的博客，希望我们能够在这共同学习共同进步！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
